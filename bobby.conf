[global]
# We use a leaky bucket algorithm here,
#
# The general idea is that for each event we add a weight
# and then the next time we subtract a multiplier of the
# time that has passed since the last time, Time is in ns.
#
# This translates to 1 second
weight = 1000000

# Maximum is 9 straight seconds
limit = 9000000

# Leak is time passed in ns since the last event multiplied
# by 10, in this case.
leak = 10

# optional, print statistics every now and then (seconds)
status_timer = 60

# You can define multiple interfaces with multiple networks.
[interface]
# optional, interface name, overrules any interface name specified in the group heading
name = eth0
# cidr addresses, comma separated
network = 10.1.1.0/24,10.2.1.0/24
# specifies how you want to answer
sponge = all
# optional, specifies if you want to use unicast or broadcast - defaults to unicast
broadcast = true
# optional, used to disable sending responses on a interface
enabled = false
# optional, used to dump packet data for verification
debug = true
# optional, prints information on weight and which ip was affected, useful for checking the leaky bucket
verbose = false

[interface eth1]
network = 172.16.0.0/24
sponge = all

# sponge can be:
# reply:
# 	Send an unsollicited unicast reply, so fake a reply
# 	ARP <IP-A> IS AT <MAC-A>
#
# request:
# 	Ask for the requestors ip as if it was the target
#	ARP WHO HAS <IP-B> TELL <IP-A>@<MAC-A>
#
#	Where IP-B asked for IP-A
#
# gratuitous:
# 	Ask for your own ip with your own data ie
# 	ARP WHO HAS <IP-A> TELL <IP-A>@<MAC-A
#
# all:
# 	All of the above
#
# none:
# 	None of the above ;)
